{
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GetFilesTextContent",
            "id": "GetFilesTextContent-kkcTY",
            "name": "documents",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data_inputs",
            "id": "SplitTextToDocuments-txn49",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-GetFilesTextContent-kkcTY{œdataTypeœ:œGetFilesTextContentœ,œidœ:œGetFilesTextContent-kkcTYœ,œnameœ:œdocumentsœ,œoutput_typesœ:[œDataœ]}-SplitTextToDocuments-txn49{œfieldNameœ:œdata_inputsœ,œidœ:œSplitTextToDocuments-txn49œ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "source": "GetFilesTextContent-kkcTY",
        "sourceHandle": "{œdataTypeœ: œGetFilesTextContentœ, œidœ: œGetFilesTextContent-kkcTYœ, œnameœ: œdocumentsœ, œoutput_typesœ: [œDataœ]}",
        "target": "SplitTextToDocuments-txn49",
        "targetHandle": "{œfieldNameœ: œdata_inputsœ, œidœ: œSplitTextToDocuments-txn49œ, œinputTypesœ: [œDataœ], œtypeœ: œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GetFile",
            "id": "GetFile-WOs6T",
            "name": "files",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "files",
            "id": "ConditionalRouter-4udCN",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-GetFile-WOs6T{œdataTypeœ:œGetFileœ,œidœ:œGetFile-WOs6Tœ,œnameœ:œfilesœ,œoutput_typesœ:[œDataœ]}-ConditionalRouter-4udCN{œfieldNameœ:œfilesœ,œidœ:œConditionalRouter-4udCNœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "source": "GetFile-WOs6T",
        "sourceHandle": "{œdataTypeœ: œGetFileœ, œidœ: œGetFile-WOs6Tœ, œnameœ: œfilesœ, œoutput_typesœ: [œDataœ]}",
        "target": "ConditionalRouter-4udCN",
        "targetHandle": "{œfieldNameœ: œfilesœ, œidœ: œConditionalRouter-4udCNœ, œinputTypesœ: [œDataœ], œtypeœ: œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ConditionalRouter",
            "id": "ConditionalRouter-4udCN",
            "name": "true_result",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "files_info",
            "id": "DownloadFiles-DrK1g",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-ConditionalRouter-4udCN{œdataTypeœ:œConditionalRouterœ,œidœ:œConditionalRouter-4udCNœ,œnameœ:œtrue_resultœ,œoutput_typesœ:[œDataœ]}-DownloadFiles-DrK1g{œfieldNameœ:œfiles_infoœ,œidœ:œDownloadFiles-DrK1gœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "source": "ConditionalRouter-4udCN",
        "sourceHandle": "{œdataTypeœ: œConditionalRouterœ, œidœ: œConditionalRouter-4udCNœ, œnameœ: œtrue_resultœ, œoutput_typesœ: [œMessageœ]}",
        "target": "DownloadFiles-DrK1g",
        "targetHandle": "{œfieldNameœ: œfiles_infoœ, œidœ: œDownloadFiles-DrK1gœ, œinputTypesœ: [œDataœ], œtypeœ: œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ConditionalRouter",
            "id": "ConditionalRouter-4udCN",
            "name": "false_result",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-nvJ1K",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-ConditionalRouter-4udCN{œdataTypeœ:œConditionalRouterœ,œidœ:œConditionalRouter-4udCNœ,œnameœ:œfalse_resultœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-nvJ1K{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-nvJ1Kœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "source": "ConditionalRouter-4udCN",
        "sourceHandle": "{œdataTypeœ: œConditionalRouterœ, œidœ: œConditionalRouter-4udCNœ, œnameœ: œfalse_resultœ, œoutput_typesœ: [œMessageœ]}",
        "target": "ChatOutput-nvJ1K",
        "targetHandle": "{œfieldNameœ: œinput_valueœ, œidœ: œChatOutput-nvJ1Kœ, œinputTypesœ: [œDataœ, œDataFrameœ, œMessageœ], œtypeœ: œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DownloadFiles",
            "id": "DownloadFiles-DrK1g",
            "name": "files",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "files",
            "id": "ConditionalRouter-tzgEC",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-DownloadFiles-DrK1g{œdataTypeœ:œDownloadFilesœ,œidœ:œDownloadFiles-DrK1gœ,œnameœ:œfilesœ,œoutput_typesœ:[œDataœ]}-ConditionalRouter-tzgEC{œfieldNameœ:œfilesœ,œidœ:œConditionalRouter-tzgECœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "source": "DownloadFiles-DrK1g",
        "sourceHandle": "{œdataTypeœ: œDownloadFilesœ, œidœ: œDownloadFiles-DrK1gœ, œnameœ: œfilesœ, œoutput_typesœ: [œDataœ]}",
        "target": "ConditionalRouter-tzgEC",
        "targetHandle": "{œfieldNameœ: œfilesœ, œidœ: œConditionalRouter-tzgECœ, œinputTypesœ: [œDataœ], œtypeœ: œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ConditionalRouter",
            "id": "ConditionalRouter-tzgEC",
            "name": "false_result",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-ZRyYS",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-ConditionalRouter-tzgEC{œdataTypeœ:œConditionalRouterœ,œidœ:œConditionalRouter-tzgECœ,œnameœ:œfalse_resultœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-ZRyYS{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-ZRyYSœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "source": "ConditionalRouter-tzgEC",
        "sourceHandle": "{œdataTypeœ: œConditionalRouterœ, œidœ: œConditionalRouter-tzgECœ, œnameœ: œfalse_resultœ, œoutput_typesœ: [œMessageœ]}",
        "target": "ChatOutput-ZRyYS",
        "targetHandle": "{œfieldNameœ: œinput_valueœ, œidœ: œChatOutput-ZRyYSœ, œinputTypesœ: [œDataœ, œDataFrameœ, œMessageœ], œtypeœ: œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ConditionalRouter",
            "id": "ConditionalRouter-tzgEC",
            "name": "true_result",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "files",
            "id": "GetFilesTextContent-kkcTY",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-ConditionalRouter-tzgEC{œdataTypeœ:œConditionalRouterœ,œidœ:œConditionalRouter-tzgECœ,œnameœ:œtrue_resultœ,œoutput_typesœ:[œDataœ]}-GetFilesTextContent-kkcTY{œfieldNameœ:œfilesœ,œidœ:œGetFilesTextContent-kkcTYœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "source": "ConditionalRouter-tzgEC",
        "sourceHandle": "{œdataTypeœ: œConditionalRouterœ, œidœ: œConditionalRouter-tzgECœ, œnameœ: œtrue_resultœ, œoutput_typesœ: [œMessageœ]}",
        "target": "GetFilesTextContent-kkcTY",
        "targetHandle": "{œfieldNameœ: œfilesœ, œidœ: œGetFilesTextContent-kkcTYœ, œinputTypesœ: [œDataœ], œtypeœ: œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "FileID",
            "id": "FileID-GP3AC",
            "name": "file",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "files_ids",
            "id": "GetFile-WOs6T",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-FileID-GP3AC{œdataTypeœ:œFileIDœ,œidœ:œFileID-GP3ACœ,œnameœ:œfileœ,œoutput_typesœ:[œMessageœ]}-GetFile-WOs6T{œfieldNameœ:œfiles_idsœ,œidœ:œGetFile-WOs6Tœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "source": "FileID-GP3AC",
        "sourceHandle": "{œdataTypeœ: œFileIDœ, œidœ: œFileID-GP3ACœ, œnameœ: œfileœ, œoutput_typesœ: [œMessageœ]}",
        "target": "GetFile-WOs6T",
        "targetHandle": "{œfieldNameœ: œfiles_idsœ, œidœ: œGetFile-WOs6Tœ, œinputTypesœ: [œMessageœ], œtypeœ: œstrœ}"
      },
      {
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "EnvExtractor",
            "id": "EnvExtractor-cB8mN",
            "name": "api_host",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "api_host",
            "id": "GetFileCollectionName-Yr3dp",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__EnvExtractor-cB8mN{œdataTypeœ:œEnvExtractorœ,œidœ:œEnvExtractor-cB8mNœ,œnameœ:œapi_hostœ,œoutput_typesœ:[œMessageœ]}-GetFileCollectionName-Yr3dp{œfieldNameœ:œapi_hostœ,œidœ:œGetFileCollectionName-Yr3dpœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "source": "EnvExtractor-cB8mN",
        "sourceHandle": "{œdataTypeœ: œEnvExtractorœ, œidœ: œEnvExtractor-cB8mNœ, œnameœ: œapi_hostœ, œoutput_typesœ: [œMessageœ]}",
        "target": "GetFileCollectionName-Yr3dp",
        "targetHandle": "{œfieldNameœ: œapi_hostœ, œidœ: œGetFileCollectionName-Yr3dpœ, œinputTypesœ: [œMessageœ], œtypeœ: œstrœ}"
      },
      {
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "SplitTextToDocuments",
            "id": "SplitTextToDocuments-txn49",
            "name": "documents",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "documents",
            "id": "DocSpaceQdrantVectorStoreComponent-VlsTX",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__SplitTextToDocuments-txn49{œdataTypeœ:œSplitTextToDocumentsœ,œidœ:œSplitTextToDocuments-txn49œ,œnameœ:œdocumentsœ,œoutput_typesœ:[œDataœ]}-DocSpaceQdrantVectorStoreComponent-VlsTX{œfieldNameœ:œdocumentsœ,œidœ:œDocSpaceQdrantVectorStoreComponent-VlsTXœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "source": "SplitTextToDocuments-txn49",
        "sourceHandle": "{œdataTypeœ: œSplitTextToDocumentsœ, œidœ: œSplitTextToDocuments-txn49œ, œnameœ: œdocumentsœ, œoutput_typesœ: [œDataœ]}",
        "target": "DocSpaceQdrantVectorStoreComponent-VlsTX",
        "targetHandle": "{œfieldNameœ: œdocumentsœ, œidœ: œDocSpaceQdrantVectorStoreComponent-VlsTXœ, œinputTypesœ: [œDataœ], œtypeœ: œotherœ}"
      },
      {
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GetFileCollectionName",
            "id": "GetFileCollectionName-Yr3dp",
            "name": "collection_name",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "collection_name",
            "id": "DocSpaceQdrantVectorStoreComponent-VlsTX",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__GetFileCollectionName-Yr3dp{œdataTypeœ:œGetFileCollectionNameœ,œidœ:œGetFileCollectionName-Yr3dpœ,œnameœ:œcollection_nameœ,œoutput_typesœ:[œMessageœ]}-DocSpaceQdrantVectorStoreComponent-VlsTX{œfieldNameœ:œcollection_nameœ,œidœ:œDocSpaceQdrantVectorStoreComponent-VlsTXœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "source": "GetFileCollectionName-Yr3dp",
        "sourceHandle": "{œdataTypeœ: œGetFileCollectionNameœ, œidœ: œGetFileCollectionName-Yr3dpœ, œnameœ: œcollection_nameœ, œoutput_typesœ: [œMessageœ]}",
        "target": "DocSpaceQdrantVectorStoreComponent-VlsTX",
        "targetHandle": "{œfieldNameœ: œcollection_nameœ, œidœ: œDocSpaceQdrantVectorStoreComponent-VlsTXœ, œinputTypesœ: [œMessageœ], œtypeœ: œstrœ}"
      },
      {
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "EnvExtractor",
            "id": "EnvExtractor-cB8mN",
            "name": "qdrant_host",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "qdrant_host",
            "id": "DocSpaceQdrantVectorStoreComponent-VlsTX",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__EnvExtractor-cB8mN{œdataTypeœ:œEnvExtractorœ,œidœ:œEnvExtractor-cB8mNœ,œnameœ:œqdrant_hostœ,œoutput_typesœ:[œMessageœ]}-DocSpaceQdrantVectorStoreComponent-VlsTX{œfieldNameœ:œqdrant_hostœ,œidœ:œDocSpaceQdrantVectorStoreComponent-VlsTXœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "source": "EnvExtractor-cB8mN",
        "sourceHandle": "{œdataTypeœ: œEnvExtractorœ, œidœ: œEnvExtractor-cB8mNœ, œnameœ: œqdrant_hostœ, œoutput_typesœ: [œMessageœ]}",
        "target": "DocSpaceQdrantVectorStoreComponent-VlsTX",
        "targetHandle": "{œfieldNameœ: œqdrant_hostœ, œidœ: œDocSpaceQdrantVectorStoreComponent-VlsTXœ, œinputTypesœ: [œMessageœ], œtypeœ: œstrœ}"
      },
      {
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "EnvExtractor",
            "id": "EnvExtractor-cB8mN",
            "name": "qdrant_port",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "qdrant_port",
            "id": "DocSpaceQdrantVectorStoreComponent-VlsTX",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__EnvExtractor-cB8mN{œdataTypeœ:œEnvExtractorœ,œidœ:œEnvExtractor-cB8mNœ,œnameœ:œqdrant_portœ,œoutput_typesœ:[œMessageœ]}-DocSpaceQdrantVectorStoreComponent-VlsTX{œfieldNameœ:œqdrant_portœ,œidœ:œDocSpaceQdrantVectorStoreComponent-VlsTXœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "source": "EnvExtractor-cB8mN",
        "sourceHandle": "{œdataTypeœ: œEnvExtractorœ, œidœ: œEnvExtractor-cB8mNœ, œnameœ: œqdrant_portœ, œoutput_typesœ: [œMessageœ]}",
        "target": "DocSpaceQdrantVectorStoreComponent-VlsTX",
        "targetHandle": "{œfieldNameœ: œqdrant_portœ, œidœ: œDocSpaceQdrantVectorStoreComponent-VlsTXœ, œinputTypesœ: [œMessageœ], œtypeœ: œstrœ}"
      },
      {
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TogetherAIEmbeddings",
            "id": "TogetherAIEmbeddings-GclNE",
            "name": "embeddings",
            "output_types": [
              "Embeddings"
            ]
          },
          "targetHandle": {
            "fieldName": "embedding",
            "id": "DocSpaceQdrantVectorStoreComponent-VlsTX",
            "inputTypes": [
              "Embeddings"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__TogetherAIEmbeddings-GclNE{œdataTypeœ:œTogetherAIEmbeddingsœ,œidœ:œTogetherAIEmbeddings-GclNEœ,œnameœ:œembeddingsœ,œoutput_typesœ:[œEmbeddingsœ]}-DocSpaceQdrantVectorStoreComponent-VlsTX{œfieldNameœ:œembeddingœ,œidœ:œDocSpaceQdrantVectorStoreComponent-VlsTXœ,œinputTypesœ:[œEmbeddingsœ],œtypeœ:œotherœ}",
        "source": "TogetherAIEmbeddings-GclNE",
        "sourceHandle": "{œdataTypeœ: œTogetherAIEmbeddingsœ, œidœ: œTogetherAIEmbeddings-GclNEœ, œnameœ: œembeddingsœ, œoutput_typesœ: [œEmbeddingsœ]}",
        "target": "DocSpaceQdrantVectorStoreComponent-VlsTX",
        "targetHandle": "{œfieldNameœ: œembeddingœ, œidœ: œDocSpaceQdrantVectorStoreComponent-VlsTXœ, œinputTypesœ: [œEmbeddingsœ], œtypeœ: œotherœ}"
      },
      {
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DocSpaceQdrantVectorStoreComponent",
            "id": "DocSpaceQdrantVectorStoreComponent-VlsTX",
            "name": "success",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-RprLp",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__DocSpaceQdrantVectorStoreComponent-VlsTX{œdataTypeœ:œDocSpaceQdrantVectorStoreComponentœ,œidœ:œDocSpaceQdrantVectorStoreComponent-VlsTXœ,œnameœ:œsuccessœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-RprLp{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-RprLpœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "source": "DocSpaceQdrantVectorStoreComponent-VlsTX",
        "sourceHandle": "{œdataTypeœ: œDocSpaceQdrantVectorStoreComponentœ, œidœ: œDocSpaceQdrantVectorStoreComponent-VlsTXœ, œnameœ: œsuccessœ, œoutput_typesœ: [œMessageœ]}",
        "target": "ChatOutput-RprLp",
        "targetHandle": "{œfieldNameœ: œinput_valueœ, œidœ: œChatOutput-RprLpœ, œinputTypesœ: [œDataœ, œDataFrameœ, œMessageœ], œtypeœ: œotherœ}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "DownloadFiles-DrK1g",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Download multiple files concurrently from OnlyOffice",
            "display_name": "Download Files",
            "documentation": "",
            "edited": false,
            "field_order": [
              "files_info",
              "asc_auth_key"
            ],
            "frozen": false,
            "icon": "file-download",
            "legacy": false,
            "lf_version": "1.1.5",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Files",
                "method": "download_files",
                "name": "files",
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "asc_auth_key": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Auth key",
                "dynamic": false,
                "info": "Auth key to use",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": true,
                "name": "asc_auth_key",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "asc_auth_key"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import asyncio\nimport aiohttp\nfrom typing import List, Dict, Any\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DataInput, MessageTextInput\nfrom langflow.io import Output\nfrom langflow.schema import Data, Message\n\n\nclass DownloadFilesContentComponent(Component):\n    \"\"\"Component for downloading file content from DocSpace via API.\"\"\"\n\n\n    display_name: str = \"Download Files\"\n    description: str = \"Downloads file content from DocSpace using viewUrl, retrieving binary content and metadata including content type, size, and version\"\n    name: str = \"DownloadFiles\"\n    icon = \"file-download\"\n\n    inputs = [\n        DataInput(\n            name=\"files_info\",\n            display_name=\"Files Info\",\n            info=\"List of file information to download\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"asc_auth_key\",\n            display_name=\"Auth key\",\n            info=\"Auth key to use\",\n            required=True,\n        )\n    ]\n\n    outputs = [\n        Output(\n            name=\"files\",\n            display_name=\"Files\",\n            method=\"download_files\",\n        ),\n    ]\n\n    async def download_file(self, session: aiohttp.ClientSession, file_info: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        Download a single file using async HTTP request.\n\n        Args:\n            session: aiohttp client session\n            file_info: Dictionary containing file information\n\n        Returns:\n            Dictionary with file content and metadata\n        \"\"\"\n        try:\n            headers = {\n                'Authorization': self.asc_auth_key,\n            }\n\n            download_url = file_info.get('viewUrl')\n            if not download_url:\n                raise ValueError(f\"Missing viewUrl in file info: {file_info}\")\n\n            async with session.get(download_url, headers=headers, timeout=30) as response:\n                response.raise_for_status()\n                content = await response.read()\n                content_type = response.headers.get('content-type', '')\n\n                return {\n                    'content': content,\n                    'content_type': content_type,\n                    'extension': file_info.get('fileExst', '').lower(),\n                    'title': file_info.get('title', ''),\n                    'version': file_info.get('version', ''),\n                    'id': file_info.get('id', ''),\n                    'size': len(content)\n                }\n\n        except Exception as e:\n            print(\n                f\"Error downloading file {file_info.get('id', 'unknown')}: {str(e)}\")\n            return None\n\n    async def fetch_all_files(self, files_info: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        \"\"\"\n        Download all files concurrently using aiohttp.\n\n        Args:\n            files_info: List of file information dictionaries\n\n        Returns:\n            List of dictionaries with file contents and metadata\n        \"\"\"\n        async with aiohttp.ClientSession() as session:\n            # Create tasks for all file downloads\n            tasks = [self.download_file(session, file_info)\n                     for file_info in files_info]\n            # Wait for all tasks to complete (like Promise.all)\n            results = await asyncio.gather(*tasks)\n            # Filter out None results (failed downloads)\n            return [r for r in results if r is not None]\n\n    async def download_files(self) -> Data:\n        \"\"\"\n        Download multiple files concurrently.\n\n        Returns:\n            Data object containing downloaded files\n        \"\"\"\n        try:\n            # Get files info from input\n            files_data = self.files_info\n            if not isinstance(files_data, Data) or not files_data.data:\n                return Data(data={\"files\": []})\n\n            files_info = files_data.data.get(\"files\", [])\n            if not files_info:\n                return Data(data={\"files\": []})\n\n            # Download all files concurrently\n            downloaded_files = await self.fetch_all_files(files_info)\n            return Data(data={\"files\": downloaded_files})\n\n        except Exception as e:\n            raise ValueError(f\"Error downloading files: {str(e)}\")\n"
              },
              "files_info": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "Files Info",
                "dynamic": false,
                "info": "List of file information to download",
                "input_types": [
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "files_info",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "DownloadFiles"
        },
        "dragging": false,
        "id": "DownloadFiles-DrK1g",
        "measured": {
          "height": 294,
          "width": 320
        },
        "position": {
          "x": -117.35483805895916,
          "y": 649.478289126599
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "description": "Extract text content from files (PDF, DOCX, XLSX, etc)",
          "display_name": "Get File Text Content",
          "id": "GetFilesTextContent-kkcTY",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extract text content from files (PDF, DOCX, XLSX, etc)",
            "display_name": "Get Files Text Content",
            "documentation": "",
            "edited": false,
            "field_order": [
              "files"
            ],
            "frozen": false,
            "icon": "file-text",
            "legacy": false,
            "lf_version": "1.1.5",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Documents",
                "method": "parse_file",
                "name": "documents",
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import io\nfrom typing import Dict, Any, List\n\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DataInput\nfrom langflow.io import Output\nfrom langflow.schema import Data, Message\n\n\nclass GetFilesTextContentComponent(Component):\n    \"\"\"Component for extracting text content from different file types.\"\"\"\n\n    display_name: str = \"Get Files Text Content\"\n    description: str = \"Extract text content from files (PDF, DOCX, XLSX, etc)\"\n    name: str = \"GetFilesTextContent\"\n    icon = \"file-text\"\n\n    inputs = [\n        DataInput(\n            name=\"files\",\n            display_name=\"Files\",\n            info=\"Files data from download_files component\",\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            name=\"documents\",\n            display_name=\"Documents\",\n            method=\"parse_file\",\n        ),\n    ]\n\n    def _parse_pdf(self, content: bytes) -> str:\n        \"\"\"Extract text from PDF file.\"\"\"\n        try:\n            from pypdf import PdfReader\n            pdf_file = io.BytesIO(content)\n            pdf_reader = PdfReader(pdf_file)\n            text = ''\n            for page in pdf_reader.pages:\n                text += page.extract_text() + '\\n'\n            return text\n        except ImportError:\n            return \"[Error: PDF parsing library not installed]\"\n\n    def _clean_text(self, text: str) -> str:\n        \"\"\"Clean up text by removing extra whitespace and normalizing spaces.\"\"\"\n        # Normalize whitespace first\n        text = ' '.join(text.split())\n\n        # Fix common word breaks and formatting issues\n        text = text.replace(' .', '.')\n        text = text.replace(' ,', ',')\n        text = text.replace(' :', ':')\n        text = text.replace(' ;', ';')\n        text = text.replace(' )', ')')\n        text = text.replace('( ', '(')\n\n        # Fix broken words (e.g., 'O NLYOFFICE' -> 'ONLYOFFICE')\n        common_breaks = [\n            ('O NLYOFFICE', 'ONLYOFFICE'),\n            ('HTML 5', 'HTML5'),\n            ('M S', 'MS'),\n            ('Google Docs', 'GoogleDocs'),\n            ('Office 365', 'Office365')\n        ]\n        for broken, fixed in common_breaks:\n            text = text.replace(broken, fixed)\n\n        # Remove redundant spaces around special characters\n        special_chars = ['-', '/', '\\\\', '&']\n        for char in special_chars:\n            text = text.replace(f' {char} ', char)\n\n        return text.strip()\n\n    def _extract_shape_text(self, shape) -> str:\n        \"\"\"Extract text from a shape or inline object.\"\"\"\n        text = ''\n        try:\n            # Try to get text from shape properties\n            if hasattr(shape, 'text'):\n                text = shape.text\n            elif hasattr(shape, 'text_frame'):\n                text = shape.text_frame.text\n            # Add more shape text extraction methods as needed\n        except Exception:\n            pass\n        return self._clean_text(text)\n\n    def _parse_run_elements(self, paragraph) -> str:\n        \"\"\"Extract text from paragraph run elements including shapes.\"\"\"\n        text_parts = []\n        current_text = ''\n\n        for run in paragraph.runs:\n            # Get regular text\n            if run.text.strip():\n                # If there's a space before and after, preserve it\n                if current_text and not current_text.endswith(' ') and not run.text.startswith(' '):\n                    current_text += ' '\n                current_text += run.text\n\n            # Get text from shapes in the run\n            if hasattr(run, '_element'):\n                for elem in run._element:\n                    if hasattr(elem, 'graphic'):\n                        shape_text = self._extract_shape_text(elem)\n                        if shape_text:\n                            if current_text:\n                                text_parts.append(\n                                    self._clean_text(current_text))\n                                current_text = ''\n                            text_parts.append(f\"[Shape] {shape_text}\")\n\n        if current_text:\n            text_parts.append(self._clean_text(current_text))\n\n        return ' '.join(text_parts)\n\n    def _parse_docx(self, content: bytes) -> str:\n        \"\"\"Extract text from DOCX file including all content types.\"\"\"\n        # Try to parse as regular DOCX first\n        try:\n            from docx import Document\n            docx_file = io.BytesIO(content)\n            doc = Document(docx_file)\n            return self._parse_docx_document(doc)\n        except ImportError:\n            return \"[Error: DOCX parsing library not installed]\"\n        except Exception:\n            # If regular parsing fails, try raw XML parsing\n            return self._parse_docx_raw(content)\n\n    def _parse_docx_raw(self, content: bytes) -> str:\n        \"\"\"Parse text directly from DOCX XML structure.\"\"\"\n        import zipfile\n        import xml.etree.ElementTree as ET\n\n        text_parts = []\n\n        try:\n            with zipfile.ZipFile(io.BytesIO(content)) as zip_ref:\n                # Parse main document.xml\n                if 'word/document.xml' in zip_ref.namelist():\n                    with zip_ref.open('word/document.xml') as doc_xml:\n                        tree = ET.parse(doc_xml)\n                        root = tree.getroot()\n\n                        # Define namespace\n                        ns = {\n                            'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}\n\n                        # Extract text from paragraphs\n                        for para in root.findall('.//w:p', ns):\n                            para_text = []\n                            for text_elem in para.findall('.//w:t', ns):\n                                if text_elem.text:\n                                    para_text.append(text_elem.text)\n                            if para_text:\n                                text_parts.append(' '.join(para_text))\n\n                        # Extract text from text boxes and shapes\n                        for shape in root.findall('.//w:drawing//wp:docPr', {'wp': 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing'}):\n                            if 'title' in shape.attrib:\n                                text_parts.append(\n                                    f\"[Shape: {shape.attrib['title']}]\")\n                            if 'descr' in shape.attrib:\n                                text_parts.append(\n                                    f\"[Shape Description: {shape.attrib['descr']}]\")\n\n        except Exception as e:\n            text_parts.append(f\"[Error parsing DOCX: {str(e)}]\")\n\n        return '\\n'.join(text_parts)\n\n    def _parse_docx_document(self, doc) -> str:\n        \"\"\"Extract text from DOCX using python-docx library.\"\"\"\n        text_parts = []\n\n        # Get text from paragraphs including shapes\n        for paragraph in doc.paragraphs:\n            text = self._parse_run_elements(paragraph)\n            if text:\n                text_parts.append(text)\n\n        # Get text from tables\n        for table in doc.tables:\n            for row in table.rows:\n                row_texts = []\n                for cell in row.cells:\n                    cell_text = ' '.join(\n                        self._parse_run_elements(p) for p in cell.paragraphs\n                        if self._parse_run_elements(p))\n                    if cell_text:\n                        row_texts.append(cell_text)\n                if row_texts:\n                    text_parts.append('\\t'.join(row_texts))\n\n        # Get text from sections (headers/footers)\n        for section in doc.sections:\n            # Header\n            if section.header:\n                header_texts = []\n                for paragraph in section.header.paragraphs:\n                    text = self._parse_run_elements(paragraph)\n                    if text:\n                        header_texts.append(text)\n                if header_texts:\n                    text_parts.append(f\"[Header] {' '.join(header_texts)}\")\n\n            # Footer\n            if section.footer:\n                footer_texts = []\n                for paragraph in section.footer.paragraphs:\n                    text = self._parse_run_elements(paragraph)\n                    if text:\n                        footer_texts.append(text)\n                if footer_texts:\n                    text_parts.append(f\"[Footer] {' '.join(footer_texts)}\")\n\n        # Clean up and join all parts with proper spacing\n        cleaned_parts = []\n        for part in text_parts:\n            if part.strip():\n                # Handle special section markers\n                if part.startswith('[') and ']' in part:\n                    cleaned_parts.append(part)  # Keep section markers as is\n                else:\n                    # Clean and add only if not empty after cleaning\n                    cleaned = self._clean_text(part)\n                    if cleaned:\n                        cleaned_parts.append(cleaned)\n\n        return '\\n'.join(cleaned_parts)\n\n    def _parse_xlsx(self, content: bytes) -> str:\n        \"\"\"Extract text from XLSX file.\"\"\"\n        try:\n            import openpyxl\n            xlsx_file = io.BytesIO(content)\n            workbook = openpyxl.load_workbook(xlsx_file, data_only=True)\n            text = []\n\n            for sheet in workbook.worksheets:\n                text.append(f\"Sheet: {sheet.title}\")\n                for row in sheet.iter_rows(values_only=True):\n                    # Filter out None values and convert all to strings\n                    row_text = [str(cell) for cell in row if cell is not None]\n                    if row_text:  # Only add non-empty rows\n                        text.append('\\t'.join(row_text))\n                text.append('')  # Add blank line between sheets\n\n            return '\\n'.join(text)\n        except ImportError:\n            return \"[Error: XLSX parsing library not installed]\"\n        except Exception as e:\n            return f\"[Error parsing XLSX: {str(e)}]\"\n\n    def _parse_text(self, content: bytes) -> str:\n        \"\"\"Extract text from text-based files.\"\"\"\n        try:\n            return content.decode('utf-8')\n        except UnicodeDecodeError:\n            # Try different encodings if UTF-8 fails\n            encodings = ['latin-1', 'cp1252', 'ascii']\n            for encoding in encodings:\n                try:\n                    return content.decode(encoding)\n                except UnicodeDecodeError:\n                    continue\n            raise ValueError(\n                \"Could not decode text content with any supported encoding\")\n\n    def _parse_pptx(self, content: bytes) -> str:\n        \"\"\"Extract text from PPTX file including all content types.\"\"\"\n        try:\n            # Try regular parsing first\n            from pptx import Presentation\n            pptx_file = io.BytesIO(content)\n            prs = Presentation(pptx_file)\n            return self._parse_pptx_presentation(prs)\n        except ImportError:\n            return \"[Error: PPTX parsing library not installed]\"\n        except Exception:\n            # Fall back to raw XML parsing\n            return self._parse_pptx_raw(content)\n\n    def _parse_pptx_presentation(self, prs) -> str:\n        \"\"\"Parse PPTX using python-pptx library.\"\"\"\n        text_parts = []\n\n        for i, slide in enumerate(prs.slides, 1):\n            slide_parts = [f\"[Slide {i}]\"]\n\n            # Get text from shapes\n            for shape in slide.shapes:\n                if hasattr(shape, 'text') and shape.text.strip():\n                    # Handle tables specially\n                    if shape.has_table:\n                        rows = []\n                        for row in shape.table.rows:\n                            row_texts = []\n                            for cell in row.cells:\n                                if cell.text.strip():\n                                    row_texts.append(cell.text.strip())\n                            if row_texts:\n                                rows.append('\\t'.join(row_texts))\n                        if rows:\n                            slide_parts.append('[Table]\\n' + '\\n'.join(rows))\n                    else:\n                        # Regular shape text\n                        slide_parts.append(shape.text.strip())\n\n                # Get text from grouped shapes\n                if hasattr(shape, 'shapes'):\n                    for subshape in shape.shapes:\n                        if hasattr(subshape, 'text') and subshape.text.strip():\n                            slide_parts.append(subshape.text.strip())\n\n            if len(slide_parts) > 1:  # If we have more than just the slide header\n                text_parts.extend(slide_parts)\n\n        return '\\n'.join(text_parts)\n\n    def _parse_pptx_raw(self, content: bytes) -> str:\n        \"\"\"Parse text directly from PPTX XML structure.\"\"\"\n        import zipfile\n        import xml.etree.ElementTree as ET\n\n        text_parts = []\n\n        try:\n            with zipfile.ZipFile(io.BytesIO(content)) as zip_ref:\n                # Get list of all slide files\n                slide_files = [f for f in zip_ref.namelist(\n                ) if f.startswith('ppt/slides/slide')]\n                slide_files.sort()\n\n                for i, slide_file in enumerate(slide_files, 1):\n                    slide_parts = [f\"[Slide {i}]\"]\n\n                    with zip_ref.open(slide_file) as slide_xml:\n                        tree = ET.parse(slide_xml)\n                        root = tree.getroot()\n\n                        # Define namespaces\n                        ns = {\n                            'a': 'http://schemas.openxmlformats.org/drawingml/2006/main',\n                            'p': 'http://schemas.openxmlformats.org/presentationml/2006/main'\n                        }\n\n                        # Extract text from text runs\n                        for text_elem in root.findall('.//a:t', ns):\n                            if text_elem.text and text_elem.text.strip():\n                                slide_parts.append(text_elem.text.strip())\n\n                        # Extract text from notes (if any)\n                        notes_file = f'ppt/notesSlides/notesSlide{i}.xml'\n                        if notes_file in zip_ref.namelist():\n                            with zip_ref.open(notes_file) as notes_xml:\n                                notes_tree = ET.parse(notes_xml)\n                                notes_root = notes_tree.getroot()\n                                notes_texts = []\n                                for text_elem in notes_root.findall('.//a:t', ns):\n                                    if text_elem.text and text_elem.text.strip():\n                                        notes_texts.append(\n                                            text_elem.text.strip())\n                                if notes_texts:\n                                    slide_parts.append(\n                                        '[Notes]\\n' + '\\n'.join(notes_texts))\n\n                    if len(slide_parts) > 1:  # If we have more than just the slide header\n                        text_parts.extend(slide_parts)\n\n        except Exception as e:\n            text_parts.append(f\"[Error parsing PPTX: {str(e)}]\")\n\n        return '\\n'.join(text_parts)\n\n    def parse_file(self) -> Data:\n        \"\"\"Parse file content based on its type and extract text.\"\"\"\n        try:\n            file_data = self.files\n            if not isinstance(file_data, Data) or not file_data.data:\n                return Data(data={\"files\": []})\n\n            files: List[Dict[str, Any]] = file_data.data.get('files', [])\n            if not files:\n                return Data(data={\"files\": []})\n\n            data = []\n\n            for file in files:\n                try:\n                    content = file.get('content')\n                    if not content:\n                        continue\n\n                    extension = file.get('extension', '').lower()\n\n                    # Extract text based on file extension\n                    if extension == '.pdf':\n                        text = self._parse_pdf(content)\n                    elif extension in ['.docx', '.doc']:\n                        text = self._parse_docx(content)\n                    elif extension in ['.xlsx', '.xls']:\n                        text = self._parse_xlsx(content)\n                    elif extension in ['.pptx', '.ppt']:\n                        text = self._parse_pptx(content)\n                    elif extension in ['.txt', '.md', '.py', '.json', '.yaml', '.yml']:\n                        text = self._parse_text(content)\n                    else:\n                        # For unsupported formats, try to parse as text\n                        try:\n                            text = self._parse_text(content)\n                        except ValueError:\n                            text = f\"[Could not extract text from file with extension {extension}]\"\n\n                    item = {\n                        'text': text,\n                        'extension': extension,\n                        'title': file.get('title', ''),\n                        'id': file.get('id', ''),\n                        'version': file.get('version', ''),\n                        'size': len(content)\n                    }\n\n                    data.append(item)\n                except Exception as e:\n                    print(\n                        f\"Error processing file {file.get('id', 'unknown')}: {str(e)}\")\n                    continue\n\n            return Data(data={\"files\": data})\n\n        except Exception as e:\n            raise ValueError(f\"Error parsing file content: {str(e)}\")\n"
              },
              "files": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "Files",
                "dynamic": false,
                "info": "Files data from download_files component",
                "input_types": [
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "files",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "GetFilesTextContent"
        },
        "dragging": false,
        "id": "GetFilesTextContent-kkcTY",
        "measured": {
          "height": 212,
          "width": 320
        },
        "position": {
          "x": 790.3266057677451,
          "y": 667.2787804362209
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "SplitTextToDocuments-txn49",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Split text into chunks based on specified criteria.",
            "display_name": "Split Text to Documents",
            "documentation": "",
            "edited": false,
            "field_order": [
              "data_inputs",
              "chunk_overlap",
              "chunk_size",
              "separator"
            ],
            "frozen": false,
            "icon": "scissors-line-dashed",
            "legacy": false,
            "lf_version": "1.1.5",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Documents",
                "method": "split_text",
                "name": "documents",
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "chunk_overlap": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Chunk Overlap",
                "dynamic": false,
                "info": "Number of characters to overlap between chunks.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chunk_overlap",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 250
              },
              "chunk_size": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Chunk Size",
                "dynamic": false,
                "info": "The maximum number of characters in each chunk.",
                "list": false,
                "list_add_label": "Add More",
                "name": "chunk_size",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1000
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Dict, Any, List\nfrom langchain_text_splitters import CharacterTextSplitter\nfrom langchain_core.documents import Document\n\nfrom langflow.custom import Component\nfrom langflow.io import DataInput, IntInput, MessageTextInput, Output\nfrom langflow.schema import Data, Message\n\n\nclass SplitTextToDocumentsComponent(Component):\n    display_name: str = \"Split Text to Documents\"\n    description: str = \"Split text into chunks based on specified criteria.\"\n    icon = \"scissors-line-dashed\"\n    name = \"SplitTextToDocuments\"\n\n    inputs = [\n        DataInput(\n            name=\"data_inputs\",\n            display_name=\"Input Content\",\n            info=\"The content to split.\",\n            required=True,\n        ),\n        IntInput(\n            name=\"chunk_overlap\",\n            display_name=\"Chunk Overlap\",\n            info=\"Number of characters to overlap between chunks.\",\n            value=200,\n        ),\n        IntInput(\n            name=\"chunk_size\",\n            display_name=\"Chunk Size\",\n            info=\"The maximum number of characters in each chunk.\",\n            value=1000,\n        ),\n        MessageTextInput(\n            name=\"separator\",\n            display_name=\"Separator\",\n            info=\"The character to split on. Defaults to newline.\",\n            value=\"\\n\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Documents\", name=\"documents\", method=\"split_text\"),\n    ]\n\n    def split_text(self) -> Data:\n        \"\"\"Split text content into chunks using CharacterTextSplitter.\n\n        Returns:\n            Data object containing list of Document objects with chunked content.\n        \"\"\"\n        try:\n            data_input = self.data_inputs\n            if not isinstance(data_input, Data) or not data_input.data:\n                return Data(data={\"documents\": []})\n\n            files: List[Dict[str, Any]] = data_input.data.get(\"files\", [])\n            if not files:\n                return Data(data={\"documents\": []})\n\n            splitter = CharacterTextSplitter(\n                chunk_overlap=self.chunk_overlap,\n                chunk_size=self.chunk_size,\n                separator=self.separator,\n            )\n\n            all_docs = {}\n\n            for file in files:\n                try:\n                    text = file.get('text')\n                    if not text:\n                        print(\n                            f\"No text content found in file {file.get('id', 'unknown')}\")\n                        continue\n\n                    metadata = {\n                        \"version\": file.get('version', ''),\n                        \"title\": file.get('title', ''),\n                        \"id\": file.get('id', ''),\n                        \"extension\": file.get('extension', '')\n                    }\n\n                    # Split the text into chunks\n                    chunks = splitter.split_text(text)\n\n                    # Create Document objects for each chunk\n                    for i, chunk in enumerate(chunks):\n                        doc = Document(\n                            page_content=chunk,\n                            metadata={\n                                **metadata,\n                                \"page\": i,\n                                \"total_pages\": len(chunks)\n                            }\n                        )\n                        all_docs[f'doc-{doc.metadata[\"id\"]}-{i}'] = doc\n\n                except Exception as e:\n                    print(\n                        f\"Error processing file {file.get('id', 'unknown')}: {str(e)}\")\n                    continue\n\n            return Data(data=all_docs)\n\n        except Exception as e:\n            raise ValueError(f\"Error splitting text: {str(e)}\")\n"
              },
              "data_inputs": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "Input Content",
                "dynamic": false,
                "info": "The content to split.",
                "input_types": [
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "data_inputs",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "separator": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Separator",
                "dynamic": false,
                "info": "The character to split on. Defaults to newline.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "separator",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "SplitTextToDocuments"
        },
        "dragging": false,
        "id": "SplitTextToDocuments-txn49",
        "measured": {
          "height": 459,
          "width": 320
        },
        "position": {
          "x": 1270.3059060467485,
          "y": 507.5370903073463
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "TogetherAIEmbeddings-GclNE",
          "node": {
            "base_classes": [
              "Embeddings"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generate embeddings using TogetherAI models.",
            "display_name": "TogetherAI Embeddings",
            "documentation": "",
            "edited": false,
            "field_order": [
              "default_headers",
              "default_query",
              "chunk_size",
              "client",
              "deployment",
              "embedding_ctx_length",
              "max_retries",
              "model",
              "model_kwargs",
              "openai_api_key",
              "openai_api_base",
              "openai_api_type",
              "openai_api_version",
              "openai_organization",
              "openai_proxy",
              "request_timeout",
              "show_progress_bar",
              "skip_empty",
              "tiktoken_model_name",
              "tiktoken_enable",
              "dimensions"
            ],
            "frozen": false,
            "icon": "TogetherAI",
            "legacy": false,
            "lf_version": "1.1.5",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Embeddings",
                "method": "build_embeddings",
                "name": "embeddings",
                "required_inputs": [
                  "openai_api_key"
                ],
                "selected": "Embeddings",
                "tool_mode": true,
                "types": [
                  "Embeddings"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "chunk_size": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Chunk Size",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "chunk_size",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1000
              },
              "client": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Client",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "client",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langchain_together import TogetherEmbeddings\n\nfrom langflow.base.embeddings.model import LCEmbeddingsModel\nfrom langflow.base.models.togetherai_constants import TOGETHERAI_EMBEDDING_MODEL_NAMES\nfrom langflow.field_typing import Embeddings\nfrom langflow.io import BoolInput, DictInput, DropdownInput, FloatInput, IntInput, MessageTextInput, SecretStrInput\n\n\nclass TogetherAIEmbeddingsComponent(LCEmbeddingsModel):\n    display_name = \"TogetherAI Embeddings\"\n    description = \"Generate embeddings using TogetherAI models.\"\n    icon = \"TogetherAI\"\n    name = \"TogetherAIEmbeddings\"\n\n    inputs = [\n        DictInput(\n            name=\"default_headers\",\n            display_name=\"Default Headers\",\n            advanced=True,\n            info=\"Default headers to use for the API request.\",\n        ),\n        DictInput(\n            name=\"default_query\",\n            display_name=\"Default Query\",\n            advanced=True,\n            info=\"Default query parameters to use for the API request.\",\n        ),\n        IntInput(name=\"chunk_size\", display_name=\"Chunk Size\",\n                 advanced=True, value=1000),\n        MessageTextInput(name=\"client\", display_name=\"Client\", advanced=True),\n        MessageTextInput(name=\"deployment\",\n                         display_name=\"Deployment\", advanced=True),\n        IntInput(name=\"embedding_ctx_length\",\n                 display_name=\"Embedding Context Length\", advanced=True, value=1536),\n        IntInput(name=\"max_retries\", display_name=\"Max Retries\",\n                 value=3, advanced=True),\n        DropdownInput(\n            name=\"model\",\n            display_name=\"Model\",\n            advanced=False,\n            options=TOGETHERAI_EMBEDDING_MODEL_NAMES,\n            value=TOGETHERAI_EMBEDDING_MODEL_NAMES[0],\n        ),\n        DictInput(name=\"model_kwargs\",\n                  display_name=\"Model Kwargs\", advanced=True),\n        SecretStrInput(name=\"openai_api_key\", display_name=\"OpenAI API Key\",\n                       value=\"OPENAI_API_KEY\", required=True),\n        MessageTextInput(name=\"openai_api_base\",\n                         display_name=\"OpenAI API Base\", advanced=True),\n        MessageTextInput(name=\"openai_api_type\",\n                         display_name=\"OpenAI API Type\", advanced=True),\n        MessageTextInput(name=\"openai_api_version\",\n                         display_name=\"OpenAI API Version\", advanced=True),\n        MessageTextInput(\n            name=\"openai_organization\",\n            display_name=\"OpenAI Organization\",\n            advanced=True,\n        ),\n        MessageTextInput(name=\"openai_proxy\",\n                         display_name=\"OpenAI Proxy\", advanced=True),\n        FloatInput(name=\"request_timeout\",\n                   display_name=\"Request Timeout\", advanced=True),\n        BoolInput(name=\"show_progress_bar\",\n                  display_name=\"Show Progress Bar\", advanced=True),\n        BoolInput(name=\"skip_empty\", display_name=\"Skip Empty\", advanced=True),\n        MessageTextInput(\n            name=\"tiktoken_model_name\",\n            display_name=\"TikToken Model Name\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"tiktoken_enable\",\n            display_name=\"TikToken Enable\",\n            advanced=True,\n            value=True,\n            info=\"If False, you must have transformers installed.\",\n        ),\n        IntInput(\n            name=\"dimensions\",\n            display_name=\"Dimensions\",\n            info=\"The number of dimensions the resulting output embeddings should have. \"\n            \"Only supported by certain models.\",\n            advanced=True,\n        ),\n    ]\n\n    def build_embeddings(self) -> Embeddings:\n        return TogetherEmbeddings(\n            client=self.client or None,\n            model=self.model,\n            api_key=self.openai_api_key or None,\n        )\n"
              },
              "default_headers": {
                "_input_type": "DictInput",
                "advanced": true,
                "display_name": "Default Headers",
                "dynamic": false,
                "info": "Default headers to use for the API request.",
                "list": false,
                "list_add_label": "Add More",
                "name": "default_headers",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "dict",
                "value": {}
              },
              "default_query": {
                "_input_type": "DictInput",
                "advanced": true,
                "display_name": "Default Query",
                "dynamic": false,
                "info": "Default query parameters to use for the API request.",
                "list": false,
                "list_add_label": "Add More",
                "name": "default_query",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "dict",
                "value": {}
              },
              "deployment": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Deployment",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "deployment",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "dimensions": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Dimensions",
                "dynamic": false,
                "info": "The number of dimensions the resulting output embeddings should have. Only supported by certain models.",
                "list": false,
                "list_add_label": "Add More",
                "name": "dimensions",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "embedding_ctx_length": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Embedding Context Length",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "embedding_ctx_length",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1536
              },
              "max_retries": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Retries",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_retries",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 3
              },
              "model": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Model",
                "dynamic": false,
                "info": "",
                "load_from_db": false,
                "name": "model",
                "options": [
                  "BAAI/bge-large-en-v1.5",
                  "WhereIsAI/UAE-Large-V1",
                  "BAAI/bge-base-en-v1.5",
                  "togethercomputer/m2-bert-80M-2k-retrieval",
                  "togethercomputer/m2-bert-80M-8k-retrieval",
                  "togethercomputer/m2-bert-80M-32k-retrieval"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "togethercomputer/m2-bert-80M-8k-retrieval"
              },
              "model_kwargs": {
                "_input_type": "DictInput",
                "advanced": true,
                "display_name": "Model Kwargs",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "model_kwargs",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "dict",
                "value": {}
              },
              "openai_api_base": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "OpenAI API Base",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "openai_api_base",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "openai_api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "OpenAI API Key",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "load_from_db": true,
                "name": "openai_api_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": "togetherai_api_key"
              },
              "openai_api_type": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "OpenAI API Type",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "openai_api_type",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "openai_api_version": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "OpenAI API Version",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "openai_api_version",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "openai_organization": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "OpenAI Organization",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "openai_organization",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "openai_proxy": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "OpenAI Proxy",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "openai_proxy",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "request_timeout": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Request Timeout",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "request_timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "float",
                "value": ""
              },
              "show_progress_bar": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Show Progress Bar",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "show_progress_bar",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "skip_empty": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Skip Empty",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "skip_empty",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "tiktoken_enable": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "TikToken Enable",
                "dynamic": false,
                "info": "If False, you must have transformers installed.",
                "list": false,
                "list_add_label": "Add More",
                "name": "tiktoken_enable",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "tiktoken_model_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "TikToken Model Name",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tiktoken_model_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "TogetherAIEmbeddings"
        },
        "dragging": false,
        "id": "TogetherAIEmbeddings-GclNE",
        "measured": {
          "height": 332,
          "width": 320
        },
        "position": {
          "x": 1296.3888243744693,
          "y": 1071.7241117546341
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GetFileCollectionName-Yr3dp",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Retrieves tenant ID from DocSpace API and formats it as a Qdrant collection name for file storage",
            "display_name": "Qdrant Collection Name",
            "documentation": "",
            "edited": false,
            "field_order": [
              "asc_auth_key",
              "api_host"
            ],
            "frozen": false,
            "icon": "database",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Collection name",
                "method": "get_file_collection_name",
                "name": "collection_name",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "api_host": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "API Service",
                "dynamic": false,
                "info": "URL of the API service",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "api_host",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "asc_auth_key": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Auth key",
                "dynamic": false,
                "info": "Auth key to use",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": true,
                "name": "asc_auth_key",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "asc_auth_key"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import requests\nfrom langflow.custom import Component\nfrom langflow.io import Output\nfrom langflow.inputs.inputs import MessageTextInput, MessageInput\nfrom langflow.schema import Message\n\n\nclass GetFilesCollectionNameComponent(Component):\n    \"\"\"Component for retrieving and formatting Qdrant collection name from DocSpace tenant ID.\"\"\"\n\n\n    display_name: str = \"Qdrant Collection Name\"\n    description: str = \"Retrieves tenant ID from DocSpace API and formats it as a Qdrant collection name for file storage\"\n    name: str = \"GetFileCollectionName\"\n    icon = \"database\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"asc_auth_key\",\n            display_name=\"Auth key\",\n            info=\"Auth key to use\",\n            required=True,\n        ),\n        MessageInput(\n            name=\"api_host\",\n            display_name=\"API Service\",\n            info=\"URL of the API service\",\n            required=True,\n        )\n    ]\n\n    outputs = [\n        Output(\n            name=\"collection_name\",\n            display_name=\"Collection name\",\n            method=\"get_file_collection_name\",\n        ),\n\n    ]\n\n    def get_file_collection_name(self) -> Message:\n        \"\"\"\n        Make an API request to get a file.\n\n        Args:\n            file_id: ID of the file to get\n\n        Returns:\n            Message object containing the response\n        \"\"\"\n        try:\n            headers = {}\n\n            headers['Authorization'] = self.asc_auth_key\n\n            api_host = self.api_host.text\n            url = f'{api_host}/api/2.0/portal'\n\n            response = requests.get(\n                url,\n                headers=headers,\n                timeout=30  # 30 second timeout\n            )\n\n            # Raise an exception for bad status codes\n            response.raise_for_status()\n\n            msg = Message(\n                text=f'files-{response.json()[\"response\"]['tenantId']}')\n\n            return msg\n\n        except requests.exceptions.RequestException as e:\n            raise ValueError(f\"Error making API request: {str(e)}\")\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "GetFileCollectionName"
        },
        "dragging": false,
        "id": "GetFileCollectionName-Yr3dp",
        "measured": {
          "height": 352,
          "width": 320
        },
        "position": {
          "x": 1607.33190170052,
          "y": -402.2740926953091
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-RprLp",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template",
              "background_color",
              "chat_icon",
              "text_color",
              "clean_data"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.1.5",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Basic Clean Data",
                "dynamic": false,
                "info": "Whether to clean the data",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, MessageTextInput, Output\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Basic Clean Data\",\n            value=True,\n            info=\"Whether to clean the data\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if not isinstance(self.input_value, Data | DataFrame | Message | str | list):\n            msg = f\"Expected Data or DataFrame or Message or str, got {type(self.input_value).__name__}\"\n            raise TypeError(msg)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                if data.get_text() is None:\n                    msg = \"Empty Data object\"\n                    raise ValueError(msg)\n                return data.get_text()\n            if isinstance(data, DataFrame):\n                if self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> str:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            return \"\\n\".join([self._safe_convert(item) for item in self.input_value])\n        return self._safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-RprLp",
        "measured": {
          "height": 66,
          "width": 192
        },
        "position": {
          "x": 2461.680821112084,
          "y": 657.3624609303232
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GetFile-WOs6T",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Make an API request to get a file from a URL",
            "display_name": "Get File",
            "documentation": "",
            "edited": false,
            "field_order": [
              "files_ids",
              "asc_auth_key"
            ],
            "frozen": false,
            "icon": "file-info",
            "legacy": false,
            "lf_version": "1.1.5",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Files",
                "method": "get_files",
                "name": "files",
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "asc_auth_key": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Auth key",
                "dynamic": false,
                "info": "Auth key to use",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": true,
                "name": "asc_auth_key",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "asc_auth_key"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import asyncio\nimport aiohttp\nfrom typing import List, Dict, Any\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import MessageInput, MessageTextInput\nfrom langflow.io import Output\nfrom langflow.schema import Data, Message\n\n\nclass GetFilesInfoComponent(Component):\n    \"\"\"Component for retrieving file information from DocSpace via API.\"\"\"\n\n\n    display_name: str = \"Get File Info\"\n    description: str = \"Retrieves detailed file information from DocSpace including metadata, permissions, and file properties\"\n    name: str = \"GetFile\"\n    icon = \"file-info\"\n\n    inputs = [\n        MessageInput(\n            name=\"files_ids\",\n            display_name=\"Files IDs\",\n            info=\"IDs of the files to get\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"asc_auth_key\",\n            display_name=\"Auth key\",\n            info=\"Auth key to use\",\n            required=True,\n        ),\n        MessageInput(\n            name=\"files_host\",\n            display_name=\"Files Service\",\n            info=\"URL of the files service\",\n            required=True,\n        )\n    ]\n\n    outputs = [\n        Output(\n            name=\"files\",\n            display_name=\"Files\",\n            method=\"get_files\",\n        ),\n    ]\n\n    async def get_file(self, session: aiohttp.ClientSession, file_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Make an async API request to get a file.\n\n        Args:\n            session: aiohttp client session\n            file_id: ID of the file to get\n\n        Returns:\n            Dict containing the file information\n        \"\"\"\n        try:\n            headers = {\n                'Authorization': self.asc_auth_key,\n            }\n\n            files_host = self.files_host.text\n            url = f'{files_host}/api/2.0/files/file/{file_id}'\n\n            async with session.get(url, headers=headers, timeout=30) as response:\n                response.raise_for_status()\n                data = await response.json()\n                return data[\"response\"]\n\n        except Exception as e:\n            print(f\"Error getting file {file_id}: {str(e)}\")\n            return None\n\n    async def fetch_all_files(self, file_ids: List[str]) -> List[Dict[str, Any]]:\n        \"\"\"\n        Fetch all files concurrently using aiohttp.\n\n        Args:\n            file_ids: List of file IDs to fetch\n\n        Returns:\n            List of file information dictionaries\n        \"\"\"\n        async with aiohttp.ClientSession() as session:\n            # Create tasks for all file fetches\n            tasks = [self.get_file(session, file_id) for file_id in file_ids]\n            # Wait for all tasks to complete (like Promise.all)\n            results = await asyncio.gather(*tasks)\n            # Filter out None results (failed requests)\n            return [r for r in results if r is not None]\n\n    async def get_files(self) -> Data:\n        \"\"\"\n        Make concurrent API requests to get multiple files.\n\n        Returns:\n            Data object containing list of file information\n        \"\"\"\n        try:\n            # Get file IDs from input data\n            files_data: List[str] = self.files_ids.data.get(\"files_ids\", [])\n            if not files_data:\n                return Data(data={\"files\": []})\n\n            # Fetch all files concurrently\n            files_info = await self.fetch_all_files(files_data)\n            return Data(data={\"files\": files_info})\n\n        except Exception as e:\n            return Data(data={\"files\": []})\n"
              },
              "files_host": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Files Service",
                "dynamic": false,
                "info": "URL of the files service",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "files_host",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "files_ids": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Files IDs",
                "dynamic": false,
                "info": "IDs of the files to get",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "files_ids",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "GetFile"
        },
        "dragging": false,
        "id": "GetFile-WOs6T",
        "measured": {
          "height": 312,
          "width": 320
        },
        "position": {
          "x": -927.5265242218509,
          "y": 604.9922990438823
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ConditionalRouter-4udCN",
          "node": {
            "base_classes": [
              "Data",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Routes an input message to a corresponding output based on text comparison.",
            "display_name": "If-Else",
            "documentation": "",
            "edited": false,
            "field_order": [
              "files"
            ],
            "frozen": false,
            "icon": "split",
            "legacy": false,
            "lf_version": "1.1.5",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "True",
                "method": "true_response",
                "name": "true_result",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "False",
                "method": "false_response",
                "name": "false_result",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "case_sensitive": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Case Sensitive",
                "dynamic": false,
                "info": "If true, the comparison will be case sensitive.",
                "list": false,
                "list_add_label": "Add More",
                "name": "case_sensitive",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import re\n\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\n\n\nclass ConditionalRouterComponent(Component):\n    display_name = \"If-Else\"\n    description = \"Routes an input message to a corresponding output based on text comparison.\"\n    icon = \"split\"\n    name = \"ConditionalRouter\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.__iteration_updated = False\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_text\",\n            display_name=\"Text Input\",\n            info=\"The primary text input for the operation.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"match_text\",\n            display_name=\"Match Text\",\n            info=\"The text input to compare against.\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"operator\",\n            display_name=\"Operator\",\n            options=[\"equals\", \"not equals\", \"contains\", \"starts with\", \"ends with\", \"regex\"],\n            info=\"The operator to apply for comparing the texts.\",\n            value=\"equals\",\n            real_time_refresh=True,\n        ),\n        BoolInput(\n            name=\"case_sensitive\",\n            display_name=\"Case Sensitive\",\n            info=\"If true, the comparison will be case sensitive.\",\n            value=False,\n        ),\n        MessageInput(\n            name=\"message\",\n            display_name=\"Message\",\n            info=\"The message to pass through either route.\",\n        ),\n        IntInput(\n            name=\"max_iterations\",\n            display_name=\"Max Iterations\",\n            info=\"The maximum number of iterations for the conditional router.\",\n            value=10,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"default_route\",\n            display_name=\"Default Route\",\n            options=[\"true_result\", \"false_result\"],\n            info=\"The default route to take when max iterations are reached.\",\n            value=\"false_result\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"True\", name=\"true_result\", method=\"true_response\"),\n        Output(display_name=\"False\", name=\"false_result\", method=\"false_response\"),\n    ]\n\n    def _pre_run_setup(self):\n        self.__iteration_updated = False\n\n    def evaluate_condition(self, input_text: str, match_text: str, operator: str, *, case_sensitive: bool) -> bool:\n        if not case_sensitive and operator != \"regex\":\n            input_text = input_text.lower()\n            match_text = match_text.lower()\n\n        if operator == \"equals\":\n            return input_text == match_text\n        if operator == \"not equals\":\n            return input_text != match_text\n        if operator == \"contains\":\n            return match_text in input_text\n        if operator == \"starts with\":\n            return input_text.startswith(match_text)\n        if operator == \"ends with\":\n            return input_text.endswith(match_text)\n        if operator == \"regex\":\n            try:\n                return bool(re.match(match_text, input_text))\n            except re.error:\n                return False  # Return False if the regex is invalid\n        return False\n\n    def iterate_and_stop_once(self, route_to_stop: str):\n        if not self.__iteration_updated:\n            self.update_ctx({f\"{self._id}_iteration\": self.ctx.get(f\"{self._id}_iteration\", 0) + 1})\n            self.__iteration_updated = True\n            if self.ctx.get(f\"{self._id}_iteration\", 0) >= self.max_iterations and route_to_stop == self.default_route:\n                route_to_stop = \"true_result\" if route_to_stop == \"false_result\" else \"false_result\"\n            self.stop(route_to_stop)\n\n    def true_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n        if result:\n            self.status = self.message\n            self.iterate_and_stop_once(\"false_result\")\n            return self.message\n        self.iterate_and_stop_once(\"true_result\")\n        return Message(content=\"\")\n\n    def false_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n        if not result:\n            self.status = self.message\n            self.iterate_and_stop_once(\"true_result\")\n            return self.message\n        self.iterate_and_stop_once(\"false_result\")\n        return Message(content=\"\")\n\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\n        if field_name == \"operator\":\n            if field_value == \"regex\":\n                build_config.pop(\"case_sensitive\", None)\n\n            # Ensure case_sensitive is present for all other operators\n            elif \"case_sensitive\" not in build_config:\n                case_sensitive_input = next(\n                    (input_field for input_field in self.inputs if input_field.name == \"case_sensitive\"), None\n                )\n                if case_sensitive_input:\n                    build_config[\"case_sensitive\"] = case_sensitive_input.to_dict()\n        return build_config\n"
              },
              "default_route": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Default Route",
                "dynamic": false,
                "info": "The default route to take when max iterations are reached.",
                "name": "default_route",
                "options": [
                  "true_result",
                  "false_result"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "false_result"
              },
              "input_text": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Text Input",
                "dynamic": false,
                "info": "The primary text input for the operation.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_text",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "match_text": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Match Text",
                "dynamic": false,
                "info": "The text input to compare against.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "match_text",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of iterations for the conditional router.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 10
              },
              "message": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Message",
                "dynamic": false,
                "info": "The message to pass through either route.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "operator": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operator",
                "dynamic": false,
                "info": "The operator to apply for comparing the texts.",
                "name": "operator",
                "options": [
                  "equals",
                  "not equals",
                  "contains",
                  "starts with",
                  "ends with",
                  "regex"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "equals"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ConditionalRouter"
        },
        "dragging": false,
        "id": "ConditionalRouter-4udCN",
        "measured": {
          "height": 260,
          "width": 320
        },
        "position": {
          "x": -537.3436232129643,
          "y": 656.5184398828338
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-nvJ1K",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template",
              "background_color",
              "chat_icon",
              "text_color",
              "clean_data"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.1.5",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Basic Clean Data",
                "dynamic": false,
                "info": "Whether to clean the data",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, MessageTextInput, Output\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Basic Clean Data\",\n            value=True,\n            info=\"Whether to clean the data\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if not isinstance(self.input_value, Data | DataFrame | Message | str | list):\n            msg = f\"Expected Data or DataFrame or Message or str, got {type(self.input_value).__name__}\"\n            raise TypeError(msg)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                if data.get_text() is None:\n                    msg = \"Empty Data object\"\n                    raise ValueError(msg)\n                return data.get_text()\n            if isinstance(data, DataFrame):\n                if self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> str:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            return \"\\n\".join([self._safe_convert(item) for item in self.input_value])\n        return self._safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-nvJ1K",
        "measured": {
          "height": 66,
          "width": 192
        },
        "position": {
          "x": -80.08804352372843,
          "y": 998.7813105104985
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ConditionalRouter-tzgEC",
          "node": {
            "base_classes": [
              "Data",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Routes an input message to a corresponding output based on text comparison.",
            "display_name": "If-Else",
            "documentation": "",
            "edited": false,
            "field_order": [
              "files"
            ],
            "frozen": false,
            "icon": "split",
            "legacy": false,
            "lf_version": "1.1.5",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "True",
                "method": "true_response",
                "name": "true_result",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "False",
                "method": "false_response",
                "name": "false_result",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "case_sensitive": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Case Sensitive",
                "dynamic": false,
                "info": "If true, the comparison will be case sensitive.",
                "list": false,
                "list_add_label": "Add More",
                "name": "case_sensitive",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import re\n\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\n\n\nclass ConditionalRouterComponent(Component):\n    display_name = \"If-Else\"\n    description = \"Routes an input message to a corresponding output based on text comparison.\"\n    icon = \"split\"\n    name = \"ConditionalRouter\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.__iteration_updated = False\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_text\",\n            display_name=\"Text Input\",\n            info=\"The primary text input for the operation.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"match_text\",\n            display_name=\"Match Text\",\n            info=\"The text input to compare against.\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"operator\",\n            display_name=\"Operator\",\n            options=[\"equals\", \"not equals\", \"contains\", \"starts with\", \"ends with\", \"regex\"],\n            info=\"The operator to apply for comparing the texts.\",\n            value=\"equals\",\n            real_time_refresh=True,\n        ),\n        BoolInput(\n            name=\"case_sensitive\",\n            display_name=\"Case Sensitive\",\n            info=\"If true, the comparison will be case sensitive.\",\n            value=False,\n        ),\n        MessageInput(\n            name=\"message\",\n            display_name=\"Message\",\n            info=\"The message to pass through either route.\",\n        ),\n        IntInput(\n            name=\"max_iterations\",\n            display_name=\"Max Iterations\",\n            info=\"The maximum number of iterations for the conditional router.\",\n            value=10,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"default_route\",\n            display_name=\"Default Route\",\n            options=[\"true_result\", \"false_result\"],\n            info=\"The default route to take when max iterations are reached.\",\n            value=\"false_result\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"True\", name=\"true_result\", method=\"true_response\"),\n        Output(display_name=\"False\", name=\"false_result\", method=\"false_response\"),\n    ]\n\n    def _pre_run_setup(self):\n        self.__iteration_updated = False\n\n    def evaluate_condition(self, input_text: str, match_text: str, operator: str, *, case_sensitive: bool) -> bool:\n        if not case_sensitive and operator != \"regex\":\n            input_text = input_text.lower()\n            match_text = match_text.lower()\n\n        if operator == \"equals\":\n            return input_text == match_text\n        if operator == \"not equals\":\n            return input_text != match_text\n        if operator == \"contains\":\n            return match_text in input_text\n        if operator == \"starts with\":\n            return input_text.startswith(match_text)\n        if operator == \"ends with\":\n            return input_text.endswith(match_text)\n        if operator == \"regex\":\n            try:\n                return bool(re.match(match_text, input_text))\n            except re.error:\n                return False  # Return False if the regex is invalid\n        return False\n\n    def iterate_and_stop_once(self, route_to_stop: str):\n        if not self.__iteration_updated:\n            self.update_ctx({f\"{self._id}_iteration\": self.ctx.get(f\"{self._id}_iteration\", 0) + 1})\n            self.__iteration_updated = True\n            if self.ctx.get(f\"{self._id}_iteration\", 0) >= self.max_iterations and route_to_stop == self.default_route:\n                route_to_stop = \"true_result\" if route_to_stop == \"false_result\" else \"false_result\"\n            self.stop(route_to_stop)\n\n    def true_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n        if result:\n            self.status = self.message\n            self.iterate_and_stop_once(\"false_result\")\n            return self.message\n        self.iterate_and_stop_once(\"true_result\")\n        return Message(content=\"\")\n\n    def false_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n        if not result:\n            self.status = self.message\n            self.iterate_and_stop_once(\"true_result\")\n            return self.message\n        self.iterate_and_stop_once(\"false_result\")\n        return Message(content=\"\")\n\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\n        if field_name == \"operator\":\n            if field_value == \"regex\":\n                build_config.pop(\"case_sensitive\", None)\n\n            # Ensure case_sensitive is present for all other operators\n            elif \"case_sensitive\" not in build_config:\n                case_sensitive_input = next(\n                    (input_field for input_field in self.inputs if input_field.name == \"case_sensitive\"), None\n                )\n                if case_sensitive_input:\n                    build_config[\"case_sensitive\"] = case_sensitive_input.to_dict()\n        return build_config\n"
              },
              "default_route": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Default Route",
                "dynamic": false,
                "info": "The default route to take when max iterations are reached.",
                "name": "default_route",
                "options": [
                  "true_result",
                  "false_result"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "false_result"
              },
              "input_text": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Text Input",
                "dynamic": false,
                "info": "The primary text input for the operation.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_text",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "match_text": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Match Text",
                "dynamic": false,
                "info": "The text input to compare against.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "match_text",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of iterations for the conditional router.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 10
              },
              "message": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Message",
                "dynamic": false,
                "info": "The message to pass through either route.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "operator": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operator",
                "dynamic": false,
                "info": "The operator to apply for comparing the texts.",
                "name": "operator",
                "options": [
                  "equals",
                  "not equals",
                  "contains",
                  "starts with",
                  "ends with",
                  "regex"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "equals"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ConditionalRouter"
        },
        "dragging": false,
        "id": "ConditionalRouter-tzgEC",
        "measured": {
          "height": 260,
          "width": 320
        },
        "position": {
          "x": 317.1287280376184,
          "y": 649.4064398844075
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-ZRyYS",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template",
              "background_color",
              "chat_icon",
              "text_color",
              "clean_data"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.1.5",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Basic Clean Data",
                "dynamic": false,
                "info": "Whether to clean the data",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, MessageTextInput, Output\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Basic Clean Data\",\n            value=True,\n            info=\"Whether to clean the data\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if not isinstance(self.input_value, Data | DataFrame | Message | str | list):\n            msg = f\"Expected Data or DataFrame or Message or str, got {type(self.input_value).__name__}\"\n            raise TypeError(msg)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                if data.get_text() is None:\n                    msg = \"Empty Data object\"\n                    raise ValueError(msg)\n                return data.get_text()\n            if isinstance(data, DataFrame):\n                if self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> str:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            return \"\\n\".join([self._safe_convert(item) for item in self.input_value])\n        return self._safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-ZRyYS",
        "measured": {
          "height": 66,
          "width": 192
        },
        "position": {
          "x": 833.3503135399083,
          "y": 1030.4075404707585
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "FileID-GP3AC",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Enter file ID to start vectorize.",
            "display_name": "File id",
            "documentation": "",
            "edited": true,
            "field_order": [
              "input_value"
            ],
            "frozen": false,
            "icon": "type",
            "legacy": false,
            "lf_version": "1.1.5",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": null,
                "method": "file_id",
                "name": "file",
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"File id\"\n    description = \"Enter file ID to start vectorize.\"\n    icon = \"type\"\n    name = \"FileID\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"File id\",\n            info=\"File id for start flow.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"file\", method=\"file_id\"),\n    ]\n\n    def file_id(self) -> Message:\n        files = self.input_value\n        files_list = files.split(',')\n        return Message(\n            text=\"Start flow\",\n            data={'files_ids': files_list},\n        )\n"
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "display_name": "File id",
                "dynamic": false,
                "info": "File id for start flow.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "2,3"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "FileID"
        },
        "dragging": false,
        "id": "FileID-GP3AC",
        "measured": {
          "height": 230,
          "width": 320
        },
        "position": {
          "x": -1396.1756092246787,
          "y": 659.2532758455109
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "EnvExtractor-cB8mN",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extract environment variables for DocSpace services",
            "display_name": "Environment Variables Extractor",
            "documentation": "",
            "edited": false,
            "field_order": [],
            "frozen": false,
            "icon": "settings",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "API Service",
                "method": "get_api_host",
                "name": "api_host",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Files Service",
                "method": "get_files_host",
                "name": "files_host",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Qdrant Service",
                "method": "get_qdrant_host",
                "name": "qdrant_host",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Qdrant Port",
                "method": "get_qdrant_port",
                "name": "qdrant_port",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import os\nfrom langflow.custom import Component\nfrom langflow.io import Output\nfrom langflow.schema import Message\n\n\nclass EnvExtractorComponent(Component):\n    \"\"\"Component for extracting environment variables.\"\"\"\n\n    display_name: str = \"Environment Variables Extractor\"\n    description: str = \"Extract environment variables for DocSpace services\"\n    name: str = \"EnvExtractor\"\n    icon = \"settings\"\n\n    outputs = [\n        Output(\n            name=\"api_host\",\n            display_name=\"API Service\",\n            method=\"get_api_host\",\n        ),\n        Output(\n            name=\"files_host\",\n            display_name=\"Files Service\",\n            method=\"get_files_host\",\n        ),\n        Output(\n            name=\"qdrant_host\",\n            display_name=\"Qdrant Service\",\n            method=\"get_qdrant_host\",\n        ),\n        Output(\n            name=\"qdrant_port\",\n            display_name=\"Qdrant Port\",\n            method=\"get_qdrant_port\",\n        ),\n    ]\n\n    def get_api_host(self) -> Message:\n        \"\"\"\n        Get the API service host from environment variables.\n\n        Returns:\n            Message object containing the API host URL\n        \"\"\"\n        try:\n            api_host = os.environ.get(\n                'HOST_API_SERVICE', 'http://onlyoffice-api:5050')\n            return Message(text=api_host)\n        except Exception as e:\n            raise ValueError(f\"Error getting API host: {str(e)}\")\n\n    def get_files_host(self) -> Message:\n        \"\"\"\n        Get the Files service host from environment variables.\n\n        Returns:\n            Message object containing the Files host URL\n        \"\"\"\n        try:\n            files_host = os.environ.get(\n                'HOST_FILES_SERVICE', 'http://onlyoffice-files:5050')\n            return Message(text=files_host)\n        except Exception as e:\n            raise ValueError(f\"Error getting Files host: {str(e)}\")\n\n    def get_qdrant_host(self) -> Message:\n        \"\"\"\n        Get the Qdrant service host from environment variables.\n\n        Returns:\n            Message object containing the Qdrant host URL\n        \"\"\"\n        try:\n            qdrant_host = os.environ.get(\n                'HOST_QDRANT_SERVICE', 'onlyoffice-qdrant')\n            return Message(text=qdrant_host)\n        except Exception as e:\n            raise ValueError(f\"Error getting Qdrant host: {str(e)}\")\n            \n    def get_qdrant_port(self) -> Message:\n        \"\"\"\n        Get the Qdrant service port from environment variables.\n\n        Returns:\n            Message object containing the Qdrant port\n        \"\"\"\n        try:\n            qdrant_port = os.environ.get(\n                'HOST_QDRANT_PORT', '6333')\n            return Message(text=qdrant_port)\n        except Exception as e:\n            raise ValueError(f\"Error getting Qdrant port: {str(e)}\")\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "EnvExtractor"
        },
        "dragging": false,
        "id": "EnvExtractor-cB8mN",
        "measured": {
          "height": 311,
          "width": 320
        },
        "position": {
          "x": 1037.7365822936156,
          "y": -300.141571999206
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "DocSpaceQdrantVectorStoreComponent-VlsTX",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Add documents to Qdrant Vector Store",
            "display_name": "DocsSpace Qdrant Vector Store",
            "documentation": "",
            "edited": false,
            "field_order": [
              "collection_name",
              "question",
              "restart_search",
              "qdrant_host",
              "qdrant_port",
              "documents",
              "files",
              "embedding"
            ],
            "frozen": false,
            "icon": "Qdrant",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Success",
                "method": "vectorize_documents",
                "name": "success",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Search",
                "method": "search_documents",
                "name": "search",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any, Dict, List\nfrom langchain.embeddings.base import Embeddings\nfrom langchain_community.vectorstores import Qdrant\nfrom langchain_core.documents import Document\nfrom qdrant_client import QdrantClient\nfrom qdrant_client.models import Distance, VectorParams, Filter\nfrom langflow.custom import Component\nfrom langflow.schema import Message, Data\n# from langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom langflow.io import (\n    MessageInput,\n    DataInput,\n    HandleInput,\n    Output,\n)\n\n\nclass DocSpaceQdrantVectorStoreComponent(Component):\n    display_name = \"DocsSpace Qdrant Vector Store\"\n    description = \"Add documents to Qdrant Vector Store\"\n    icon = \"Qdrant\"\n\n    inputs = [\n        MessageInput(name=\"collection_name\",\n                     display_name=\"Collection Name\",\n                     required=True),\n        MessageInput(name=\"question\",\n                     display_name=\"Question\",\n                     ),\n        MessageInput(name=\"restart_search\",\n                     display_name=\"Restart Search\",\n                     ),\n        MessageInput(name=\"qdrant_host\",\n                     display_name=\"Qdrant Host\",\n                     ),\n        MessageInput(name=\"qdrant_port\",\n                     display_name=\"Qdrant Port\",\n                     ),\n\n        DataInput(name=\"documents\", display_name=\"Documents\"),\n        DataInput(name=\"files\", display_name=\"Files\"),\n\n        HandleInput(name=\"embedding\", display_name=\"Embedding\",\n                    input_types=[\"Embeddings\"]),\n    ]\n\n    outputs = [\n        Output(name=\"success\",\n               display_name=\"Success\",\n               method=\"vectorize_documents\"),\n        Output(name=\"search\",\n               display_name=\"Search\",\n               method=\"search_documents\"),\n    ]\n\n    def check_collection_exists(self, client: QdrantClient, collection_name: str) -> bool:\n        \"\"\"Check if collection exists in Qdrant.\"\"\"\n        try:\n            collections = client.get_collections()\n            return any(collection.name == collection_name for collection in collections.collections)\n        except Exception as e:\n            raise Exception(f\"Error checking collections list: {str(e)}\")\n\n    def create_collection(self, client: QdrantClient, collection_name: str, vector_size: int) -> bool:\n        \"\"\"Create a new collection in Qdrant.\"\"\"\n        try:\n            # Create new collection\n            client.create_collection(\n                collection_name=collection_name,\n                vectors_config=VectorParams(\n                    size=vector_size,\n                    distance=Distance.COSINE\n                )\n            )\n\n            return True\n\n        except Exception as e:\n            raise Exception(\n                f\"Failed to create collection {collection_name}: {str(e)}\")\n\n    # @check_cached_vector_store\n    def build_vector_store(self) -> Qdrant:\n        try:\n            collection_name = self.collection_name.get_text()\n            embedding: Embeddings = self.embedding\n\n            qdrant_host = self.qdrant_host.get_text()\n            qdrant_port = self.qdrant_port.get_text()\n\n            # Create QdrantClient with HTTP and timeout\n            client = QdrantClient(\n                host=qdrant_host,\n                port=qdrant_port,  # HTTP/REST API port\n                prefer_grpc=False,  # Use HTTP\n                timeout=10.0  # Add timeout\n            )\n\n            if self.files:\n                if not self.check_collection_exists(client, collection_name):\n                    return None\n\n            if self.documents:\n                documents: List[Document] = list(self.documents.data.values())\n                if not documents:\n                    raise ValueError(\"No documents provided\")\n\n                # Get vector size from first document\n                vector = embedding.embed_query(documents[0].page_content)\n                vector_size = len(vector)\n\n                # Create collection if needed\n                if not self.check_collection_exists(client, collection_name):\n                    self.create_collection(\n                        client, collection_name, vector_size)\n\n            qdrant = Qdrant(client=client,\n                            embeddings=embedding,\n                            collection_name=collection_name)\n\n            return qdrant\n\n        except Exception as e:\n            raise Exception(f\"Error building vector store: {str(e)}\")\n\n    def check_document_exists(self, qdrant: Qdrant, document: Document) -> List[Document]:\n        # Only check if document has metadata with id and version\n        if not document.metadata or 'id' not in document.metadata or 'version' not in document.metadata:\n            return []\n\n        return qdrant.similarity_search(\n            query=document.page_content,\n            k=1,\n            filter=Filter(\n                must=[\n                    {\"key\": \"metadata.id\", \"match\": {\n                        \"value\": document.metadata['id']}},\n                    {\"key\": \"metadata.version\", \"match\": {\n                        \"value\": document.metadata['version']}},\n                ]\n            )\n        )\n\n    def vectorize_documents(self) -> Message:\n        try:\n            qdrant = self.build_vector_store()\n            if not self.documents:\n                return Message(text=\"No documents to process\")\n\n            docs: Dict[str, Document] = self.documents.data\n\n            documents = list(docs.values())\n\n            if not documents:\n                return Message(text=\"No documents to process\")\n\n            # Process each document chunk\n            existing = True\n\n            for i, doc in enumerate(documents, 1):\n\n                existing_doc = self.check_document_exists(\n                    qdrant, doc)\n\n                if (existing_doc and existing):\n                    existing = True\n\n                    continue\n\n                existing = False\n                # Add document to Qdrant\n                qdrant.add_documents([doc])\n\n            msg = Message(\n                role=\"system\",\n                text=f'Document {\",\".join(str(document.metadata[\"id\"]) for document in documents)} added to Qdrant'\n            )\n\n            return msg\n\n        except Exception as e:\n            raise Exception(f\"Error vectorizing documents: {str(e)}\")\n\n    def search_documents(self) -> Message:\n        files: List[Dict[str, Any]] = self.files.data.get(\"files\", [])\n\n        if not files:\n            return Message(text=\"No files found in input\")\n\n        question: str = self.question.get_text()\n\n        if not question:\n            return Message(text=\"No question provided\")\n\n        qdrant = self.build_vector_store()\n\n        if not qdrant:\n            return Message(text=\", \".join([str(file.get('id', 'unknown')) for file in files]),\n                           data={\"docs\": []})\n\n        not_found_files = []\n\n        for file in files:\n            if self.check_document_exists(qdrant, Document(\n                page_content=question,\n                metadata={\n                    \"id\": file.get('id', 'unknown'),\n                    \"version\": file.get('version', 1),\n                }\n            )):\n                continue\n\n            not_found_files.append(file)\n\n        if len(not_found_files):\n            return Message(text=\", \".join([str(file.get('id', 'unknown')) for file in files]),\n                           data={\"docs\": []})\n\n        # Create OR conditions for each file (file_id AND version must match)\n        file_conditions = [\n            {\n                \"must\": [\n                    {\"key\": \"metadata.id\", \"match\": {\n                        \"value\": file.get('id', 'unknown')}},\n                    {\"key\": \"metadata.version\", \"match\": {\n                        \"value\": file.get('version', 1)}}\n                ]\n            } for file in files\n        ]\n\n        filter: Filter = Filter(\n            should=file_conditions\n        )\n\n        docs = qdrant.similarity_search(\n            query=question,\n            k=5,\n            filter=filter\n        )\n\n        return Message(text=\", \".join([str(file.get('id', 'unknown')) for file in files]),\n                       data={\"docs\": docs})\n"
              },
              "collection_name": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Collection Name",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "collection_name",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "documents": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "Documents",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "documents",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "embedding": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Embedding",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Embeddings"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "embedding",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "files": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "Files",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "files",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "qdrant_host": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Qdrant Host",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "qdrant_host",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "qdrant_port": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Qdrant Port",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "qdrant_port",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "question": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Question",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "question",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "restart_search": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Restart Search",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "restart_search",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "DocSpaceQdrantVectorStoreComponent"
        },
        "dragging": false,
        "id": "DocSpaceQdrantVectorStoreComponent-VlsTX",
        "measured": {
          "height": 741,
          "width": 320
        },
        "position": {
          "x": 2047.9770157391888,
          "y": 284.5390658573117
        },
        "selected": false,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": 441.39885038042615,
      "y": 231.02389409139147,
      "zoom": 0.27610406378994445
    }
  },
  "description": "Language Models, Mapped and Mastered.",
  "endpoint_name": null,
  "folder_id": "74b09011-dc81-4b37-aa1a-d3f9e959985c",
  "gradient": null,
  "icon": null,
  "icon_bg_color": null,
  "id": "ab41d318-98ac-49a1-aac3-942aca80869e",
  "is_component": false,
  "locked": false,
  "name": "Vectorize document",
  "tags": null,
  "updated_at": "2025-03-13T02:08:54+00:00",
  "user_id": "31095b14-2cef-4f27-af10-1bfcfc85abba",
  "webhook": false
}